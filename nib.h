#ifndef __NIB_H
#define __NIB_H

#include <stdint.h>

typedef struct _nibSector {
  uint8_t gap1[48];

  uint8_t sectorProlog[3];
  uint8_t volume44[2];
  uint8_t track44[2];
  uint8_t sector44[2];
  uint8_t checksum44[2];
  uint8_t sectorEpilog[3];

  uint8_t gap2[5];

  uint8_t dataProlog[3];
  uint8_t data62[342];
  uint8_t checksum;
  uint8_t dataEpilog[3];
} nibSector;

#define         nib1(a) (((a & 0xAA) >> 1) | 0xAA)
#define         nib2(b) (((b & 0x55)     ) | 0xAA)
#define denib(a, b) ((((a) & ~0xAA) << 1) | ((b) & ~0xAA))

// In 6-and-2 encoding, there are 86 (0x56) 6-bit values
#define SIXBIT_SPAN 0x56

const static uint8_t _trans[64] = {0x96, 0x97, 0x9a, 0x9b, 0x9d, 0x9e, 0x9f, 0xa6,
                                   0xa7, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb2, 0xb3,
                                   0xb4, 0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbc,
                                   0xbd, 0xbe, 0xbf, 0xcb, 0xcd, 0xce, 0xcf, 0xd3,
                                   0xd6, 0xd7, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde,
                                   0xdf, 0xe5, 0xe6, 0xe7, 0xe9, 0xea, 0xeb, 0xec,
                                   0xed, 0xee, 0xef, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,
                                   0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

const static uint8_t _detrans[0x80] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
                                       0x00, 0x00, 0x08, 0x0C, 0x00, 0x10, 0x14, 0x18,
                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x20,
                                       0x00, 0x00, 0x00, 0x24, 0x28, 0x2C, 0x30, 0x34,
                                       0x00, 0x00, 0x38, 0x3C, 0x40, 0x44, 0x48, 0x4C,
                                       0x00, 0x50, 0x54, 0x58, 0x5C, 0x60, 0x64, 0x68,
                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x00, 0x6C, 0x00, 0x70, 0x74, 0x78,
                                       0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x80, 0x84,
                                       0x00, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0,
                                       0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0xA8, 0xAC,
                                       0x00, 0xB0, 0xB4, 0xB8, 0xBC, 0xC0, 0xC4, 0xC8,
                                       0x00, 0x00, 0xCC, 0xD0, 0xD4, 0xD8, 0xDC, 0xE0,
                                       0x00, 0xE4, 0xE8, 0xEC, 0xF0, 0xF4, 0xF8, 0xFC };

// dos 3.3 to physical sector conversion
const static uint8_t dephys[16] = {
  0x00, 0x07, 0x0e, 0x06, 0x0d, 0x05, 0x0c, 0x04,
  0x0b, 0x03, 0x0a, 0x02, 0x09, 0x01, 0x08, 0x0f };

// Prodos to physical sector conversion
const uint8_t deProdosPhys[] = {
  0x00, 0x08, 0x01, 0x09, 0x02, 0x0a, 0x03, 0x0b,
  0x04, 0x0c, 0x05, 0x0d, 0x06, 0x0e, 0x07, 0x0f };

#endif
